#!/usr/bin/env python
#
#  .           .
#  |"-._   _.-'|
#  \    '-"    /
#   '-._   _.-'
#      .: :.
#   ~^~^~^~^~^~
#      Flukes
#
# Quick and dirty tool to tail logs from multiple docker containers,
# with docker-compose-like coloring.
#
# -
#
# Author: Espen Notodden
# License: MIT
#

from __future__ import print_function
import time
import sys
import os
import subprocess
import threading
import Queue
import argparse
import re

COLORS = {
    "grey": 30,
    "red": 31,
    "green": 32,
    "yellow": 33,
    "blue": 34,
    "magenta": 35,
    "cyan": 36,
    "white": 37
}

RESET = '\033[0m'

#Termcolor "mini"
def colored(s, color):
    if os.getenv('ANSI_COLORS_DISABLED') is not None:
        return s
    s = '\033[' + str(COLORS[color]) + 'm' + s
    s += RESET
    return s

class ColorPicker(object):
    possible_colors = COLORS.keys()
    def __init__(self):
        self.color_index = 0
    def pick(self):
        c = self.possible_colors[self.color_index]
        self.color_index += 1
        if self.color_index == len(self.possible_colors):
            self.color_index = 0
        return c


ALL_CONTAINERS = "all"

class Flukes(object):

    def enqueue_output_container(self, out, queue, container):
        for line in iter(out.readline, b''):
            queue.put({"line": line, "container":container})
        out.close()

    def enqueue_output(self, out, queue):
        for line in iter(out.readline, b''):
            queue.put(line)
        out.close()

    def __init__(self, containers, watch=False, tail=0):

        self.cp = ColorPicker()

        self.container_colors = {}
        self.log_q = Queue.Queue()
        self.event_q = Queue.Queue()

        self.tail = tail
        self.containers = containers

        if containers == ALL_CONTAINERS:
            o = subprocess.check_output("docker ps --format '{{.Names}}'", shell=True)
            self.containers = o.split("\n")

        for container in self.containers:
            self.add_container(container, self.tail)

        if watch:
            self.watch = True
            self.setup_event_watcher()

    def setup_event_watcher(self):
        p = subprocess.Popen(["docker", "events", "--filter", "event=start"],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                bufsize=1,
                close_fds='posix' in sys.builtin_module_names)
        t = threading.Thread(target=self.enqueue_output,
                             args=(p.stdout, self.event_q))
        t.daemon = True
        t.start()

    def add_container(self, container, tail=0):
        self.container_colors[container] = self.cp.pick()

        cmd = ["docker", "logs", "-f"]
        if tail > 0:
            cmd += ["--tail", str(tail)]
        cmd += [container]

        p = subprocess.Popen(cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                bufsize=1,
                close_fds='posix' in sys.builtin_module_names)
        t = threading.Thread(target=self.enqueue_output_container,
                             args=(p.stdout, self.log_q, container))
        t.daemon = True
        t.start()

    def run(self):
        while 1:
            # Read line async
            try:
                x = self.log_q.get_nowait()
            except Queue.Empty:
                # Sleep a bit during "slow" periods.
                # Makes our tight loop a bit less tight and saves some battery :)
                time.sleep(0.1)
            else:
                container = x["container"]
                sys.stdout.write(colored(container + ": ", self.container_colors[container]) + x["line"])

            if self.watch:
                self.process_events()
                continue

    def process_events():
        while 1:
            try:
                line = self.event_q.get_nowait()
            except Queue.Empty:
                break
            else:
                container_id = re.findall(r'[a-f0-9]{64}', line)[0]
                name = self.container_name(container_id)
                print("FLUKES: Adding container " + name)
                self.add_container(name)

    def container_name(self, container_id):
        cmd = "docker inspect --format '{{.Name}}' %s" % container_id
        name = subprocess.check_output(cmd, shell=True)
        name = [1:].strip() # Remove whitespace and leading slash
        return name


def main():
    argp = argparse.ArgumentParser()
    argp.add_argument("containers", nargs="*", default="all",
        help="Containers to tail logs from. Defaults to all running containers.")
    argp.add_argument("-t", "--tail", type=int, default=-1,
        help="Number of lines to tail (passed to 'docker logs')")
    argp.add_argument("-w", "--watch", action="store_true",
        help="Watch for new containers starting")
    args = argp.parse_args()

    containers = args.containers

    t = None
    if args.containers == "all":
        t = Flukes(ALL_CONTAINERS, tail=args.tail, watch=args.watch)
    else:
        t = Flukes(args.containers, tail=args.tail, watch=args.watch)
    t.run()

if __name__ == "__main__":
    main()



